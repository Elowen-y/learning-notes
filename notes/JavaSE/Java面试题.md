# 经典面试题

1. 为什么重写 equals 还要重写 hashCode？
2. == 和 equals 比较的区别
3. 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？
4. final 关键字的作用
5. 介绍 Java 的集合类
6. ArrayList 和 LinkedList 的区别



## 1. 为什么重写 equals 还要重写 hashCode？

1. 在 java 中，当往哈希(散列)集合中添加元素时，会先去判断 hashCode 值是否相同，如果不同，则直接插入。如果相同，才去用 equals 判断。

2. 注意：

   1. 两个对象的 hashCode 值如果不同，则对象一定不同。
   2. 两个对象的 hashCode 值如果相同，则对象可能相同，也可能不同，需要用 equals 去比较。

3. Object 类中 equals 方法的源码：

   ```java
   public boolean equals(Object obj) {
   	return (this == obj);
   }
   ```

   - 对于引用类型，如果不重写 equals 方法，即使调用 equals 方法，还是默认通过 == 来比较两个对象的地址
   - 但在实际业务中，我们都是通过**属性是否相等**来判断两个对象是否为同一个。

4. 综上，不仅要重写 equals，还要重写 hashCode。



## 2. == 和 equals 比较的区别

- `==` 是运算符，如果是基本数据类型，则比较存储的**值**；如果是引用数据类型，则比较**所指向对象的地址值**。
- `equals` 是 Object 方法，比较的是所指向对象的地址值，一般情况下，**重写之后比较的是对象的值**。



## 3. 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？

- **计算机使用二进制系统来存储浮点数**，`4.0` 在二进制中可以精确表示，而 `3.6` 在二进制中是一个无限循环的小数，计算机只能使用一个**近似值**来表示它。
- 由于 `3.6` 只能近似表示，减法操作的结果也会产生近似值，而这个近似值可能不是你期望的精确结果，导致出现像 `0.40000001` 这样的结果。



## 4. final 关键字的作用

1. 修饰类（太监类）：不能被继承
2. 修饰方法：不能被重写
3. 修饰局部变量：
   1. 基本类型：变量的数据不可变
   2. 引用类型：变量的地址值不可变
4. 修饰成员变量：
   1. 由于成员变量具有默认值，所以用了 final 之后必须手动赋值，不会再给默认值了。
      1. 要么直接赋值
      2. 要么通过构造方法赋值
         1. 必须保证类当中所有的重载的构造方法，都最终会对 final 的成员变量进行赋值。



## 5. 介绍 Java 的集合类

![](https://gitee.com/the-sherry/picture/raw/master/typora/202505042312718.png)



## 6. ArrayList 和 LinkedList 的区别

|              | ArrayList                                          | LinkedList |
| ------------ | -------------------------------------------------- | ---------- |
| 底层数据结构 | 动态数组                                           | 双向链表   |
| 性能特点     | 查询速度快                                         | 增删快     |
| 适用场景     | 适合需要频繁查找特定位置数据的场景（随机访问方便） |            |

